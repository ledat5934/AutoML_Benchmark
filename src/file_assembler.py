from __future__ import annotations

from pathlib import Path
from typing import List

import nbformat as nbf

from src.utils.env_config import load_config
from src.utils.gemini_client import GeminiClient
from src.utils.logger import get_logger

logger = get_logger(__name__)


class FileAssembler:
    """Combine stage scripts into one .py and .ipynb output."""

    def _clean_with_ai(self, code: str) -> str:
        """Use Gemini to clean and combine Python code."""
        logger.info("Cleaning assembled code with AI...")
        prompt = """You are an expert Python programmer. You will be given a Python script that was generated by concatenating multiple script files. This has resulted in duplicated imports, multiple main entry points (`if __name__ == '__main__':`), and potentially redundant helper functions.
                Your task is to refactor and clean this script into a single, coherent, and executable Python file.
                Please adhere to the following rules:
                1.  **Consolidate Imports**: Merge all import statements at the top of the file and remove any duplicates.
                2.  **Single Entry Point**: Ensure there is only ONE `if __name__ == '__main__':` block. If there are multiple, merge their logic into a single `main()` function and call it from the single entry point block. If the logic is redundant, keep only one.
                3.  **Create a `main` function**: All the code that is not a function or class definition or import should be in a `main()` function. The `if __name__ == '__main__':` block should only call `main()`.
                4.  **Remove Redundancy**: Delete any duplicate or redundant functions or classes. If two functions have the same name, assume they are identical and keep only one.
                5.  **Preserve Logic**: The final script must preserve the original operational flow and logic of the combined scripts. Do NOT change the logic of the code even if it's completely wrong or redundant.
                6.  **Output Only Code**: Your output must be ONLY the raw, clean Python code. Do not wrap it in markdown backticks (e.g., ```python) or add any explanations."""
        try:
            config = load_config()
            client = GeminiClient(config)
            messages = [
                {"role": "system", "content": prompt},
                {"role": "user", "content": f"Here is the Python script to clean:\n\n{code}"},
            ]
            cleaned_code = client.chat_completion(messages=messages)
            logger.info("AI cleaning complete.")
            return cleaned_code
        except Exception as e:
            logger.error("Failed to clean code with AI: %s. Returning original code.", e)
            return code

    def assemble(
        self,
        project_name: str,
        stage_files: List[Path],
        output_root: Path,
    ) -> None:
        if not stage_files:
            raise ValueError("No stage files provided to assemble")
        output_root.mkdir(parents=True, exist_ok=True)
        py_path = output_root / f"{project_name}.py"
        nb_path = output_root / f"{project_name}.ipynb"

        logger.info("Assembling %d stage files into %s and %s", len(stage_files), py_path, nb_path)

        all_code: List[str] = []
        for p in stage_files:
            code = p.read_text(encoding="utf-8")
            all_code.append(code)

        # Combine python file
        combined = "\n\n".join(all_code)
        
        # Clean the combined code using AI
        cleaned_combined = self._clean_with_ai(combined)
        
        py_path.write_text(cleaned_combined, encoding="utf-8")

        # Build notebook
        nb = nbf.v4.new_notebook()
        for code in all_code:
            nb.cells.append(nbf.v4.new_code_cell(code))
        nbf.write(nb, str(nb_path))

        logger.info("Wrote assembled outputs to %s", output_root) 